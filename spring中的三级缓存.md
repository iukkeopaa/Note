你想知道 Spring 中循环依赖为何无法解决构造方法注入的场景，核心要从**Spring 解决循环依赖的核心原理**和**构造方法注入的特性**两个维度展开分析，下面我会逐步拆解其中的逻辑，兼顾原理和实战场景。

### 一、先铺垫：Spring 能解决的循环依赖是什么？

首先要明确，Spring 并非能解决所有循环依赖，它仅能解决「**单例 Bean + 属性注入（setter 注入）/ 字段注入**」的循环依赖（如 A→B，B→A，均为单例，通过`setXxx()`或`@Autowired`字段注入）。

Spring 解决这种循环依赖的核心依赖**三级缓存（核心是提前暴露未完全初始化的 Bean）**，核心流程简化如下：

1. 实例化 Bean A（仅调用无参构造器，创建空对象，未进行属性注入和初始化`init-method`/`@PostConstruct`）。
2. 将 Bean A 的「早期暴露对象」（未完全初始化，仅实例化完成）存入三级缓存（`singletonFactories`）。
3. 对 Bean A 进行属性注入，发现依赖 Bean B，转而创建 Bean B。
4. 实例化 Bean B，同样将其早期暴露对象存入三级缓存。
5. 对 Bean B 进行属性注入，发现依赖 Bean A，从三级缓存中取出 Bean A 的早期暴露对象，完成 Bean B 的属性注入和初始化。
6. Bean B 初始化完成，存入一级缓存（`singletonObjects`）。
7. 回到 Bean A，用已初始化完成的 Bean B 完成属性注入，最后完成 Bean A 的初始化，存入一级缓存。

这里的关键是：**Spring 在 Bean「实例化后、初始化前」就提前暴露了对象引用，让其他依赖该 Bean 的对象可以先获取到引用，完成自身的初始化，再回头完成该 Bean 的剩余初始化流程**。

### 二、核心原因：构造方法注入为何无法解决循环依赖？

构造方法注入的场景下（如 A 的构造器依赖 B，B 的构造器依赖 A），Spring 无法解决循环依赖，核心原因有 2 点，且层层递进：

#### 1.  核心根源：构造方法注入时，「实例化」与「依赖注入」无法分离，无法提前暴露对象

Spring 创建 Bean 的流程分为两大核心步骤：

- **步骤 1：实例化（Instantiation）**：创建 Bean 的对象实例，对于「无参构造器」，直接调用即可完成实例化；对于「有参构造器（构造方法注入）」，必须先获取到构造器参数对应的依赖 Bean，才能调用构造器完成实例化。
- **步骤 2：初始化（Initialization）**：完成属性注入、调用`@PostConstruct`、`init-method`等，最终形成可用的 Bean。

对于**属性注入 /setter 注入**：实例化（无参构造）和依赖注入（setXxx ()）是分离的 —— 即使依赖未就绪，也能先创建出 Bean 的空对象，再提前暴露这个对象。

但对于**构造方法注入**：

- 构造器是创建对象的「唯一入口」，要完成 Bean 的「实例化」，必须先满足构造器的所有参数依赖（即获取到对应的依赖 Bean）。

- 换句话说，

  构造方法注入中，「依赖注入」是「实例化」的前提条件，两者绑定在一起，无法分离

  。如果 A 的构造器依赖 B，B 的构造器又依赖 A，就会形成「鸡生蛋、蛋生鸡」的死循环：

  - 创建 A：需要先获取 B（构造器参数），才能调用 A 的构造器完成实例化。
  - 创建 B：需要先获取 A（构造器参数），才能调用 B 的构造器完成实例化。
  - 两者都需要对方先完成实例化，才能自身完成实例化，而无法像属性注入那样，先创建一个「不完整的早期对象」提前暴露，因此循环依赖无法打破。

  

#### 2.  三级缓存失效：无法存入「未实例化的 Bean」，提前暴露机制无立足之地

Spring 解决循环依赖的核心是「三级缓存」，但三级缓存的作用是「存储已实例化、未初始化的早期 Bean 对象」，而构造方法注入场景下：

- 由于依赖未满足，构造器无法调用，Bean 的实例化都无法完成，根本不存在「对象引用」，自然无法将其存入三级缓存供其他 Bean 获取。
- 三级缓存的提前暴露机制，是建立在「Bean 已经完成实例化，拥有可被引用的对象地址」基础上的，构造方法注入连实例化都无法完成，三级缓存也就失去了作用，无法解决循环依赖。

### 三、补充：直观示例（构造方法循环依赖）

用代码示例更能直观理解这种死循环：

java



运行









```
// Bean A：构造方法注入Bean B
@Component
public class BeanA {
    private BeanB beanB;

    // 构造方法注入，依赖BeanB
    public BeanA(BeanB beanB) {
        this.beanB = beanB;
    }
}

// Bean B：构造方法注入Bean A
@Component
public class BeanB {
    private BeanA beanA;

    // 构造方法注入，依赖BeanA
    public BeanB(BeanA beanA) {
        this.beanA = beanA;
    }
}
```

启动 Spring 容器后，会直接抛出`BeanCurrentlyInCreationException`异常，提示循环依赖无法解决，原因就是两者的构造器互相依赖，无法完成实例化。

### 四、扩展：如何解决构造方法注入的循环依赖？

如果业务中确实存在循环依赖，且需要使用构造方法注入，可通过以下 2 种方式解决：

1. **打破循环依赖：引入中间层 / 解耦**：将其中一个 Bean 的构造方法依赖，改为属性注入，分离实例化和依赖注入，让 Spring 可以提前暴露对象。
2. **使用`@Lazy`注解（延迟初始化）**：在构造器参数上添加`@Lazy`，延迟依赖 Bean 的初始化，本质是创建一个代理对象作为构造器参数，避免立即获取真实 Bean，打破循环。示例：

java



运行









```
@Component
public class BeanA {
    private BeanB beanB;

    // 对BeanB添加@Lazy，延迟初始化
    public BeanA(@Lazy BeanB beanB) {
        this.beanB = beanB;
    }
}
```

`@Lazy`的核心是：不立即创建真实的 Bean B，而是创建一个动态代理对象注入到 Bean A 的构造器中，完成 Bean A 的实例化，后续真正使用 Bean B 时，再创建真实的 Bean B 对象，从而打破循环依赖。

### 总结

1. Spring 仅能解决「单例 + 属性 /setter 注入」的循环依赖，核心是三级缓存提前暴露未完全初始化的 Bean。
2. 构造方法注入无法解决循环依赖的核心：「实例化」与「依赖注入」绑定，依赖是实例化的前提，无法提前暴露对象，三级缓存失效。
3. 构造方法循环依赖的解决方案：解耦（改为属性注入）或使用`@Lazy`延迟初始化。

那我实现了无参构造函数能解决吗

你想知道实现无参构造函数是否能解决构造方法注入引发的循环依赖问题，答案很明确：**仅实现无参构造函数，并不足以解决构造方法注入的循环依赖问题，甚至可以说这种做法对构造方法注入的循环依赖无效**。下面我们拆解其中的逻辑，理清关键区别：

### 一、先明确核心概念：「构造方法注入」与「无参构造函数」的关系

1. 你之前遇到的循环依赖，是「**带参构造方法注入**」（即 Bean 的构造器中包含依赖的 Bean 参数，如`public BeanA(BeanB beanB)`），这是引发循环依赖的根源。
2. 实现无参构造函数（`public BeanA()`），只是给 Bean 增加了一个空参的构造入口，但如果你的依赖注入逻辑仍然写在「带参构造方法」中（即仍然依赖构造器传入 BeanB），那么循环依赖的核心问题并没有得到解决。

简单说：**无参构造函数只是 Bean 的一个构造入口，并不会替代或消除你用于注入依赖的「带参构造方法」，带参构造方法的依赖约束依然存在**。

### 二、为什么仅实现无参构造函数无法解决构造方法循环依赖？

核心原因还是要回归 Spring 创建 Bean 的逻辑，以及构造方法注入的特性，具体有两点：

1. Spring 优先选择「最匹配的带参构造方法」进行实例化（若存在）

   

   Spring 容器创建 Bean 时，对于有多个构造方法的 Bean，会遵循以下优先级：

- 若通过`@Autowired`标注了带参构造方法（Spring 默认推荐的构造方法注入方式），Spring 会优先选择该带参构造方法进行实例化。
- 若未标注`@Autowired`，但存在多个构造方法，Spring 会优先选择「参数个数最多、最匹配」的带参构造方法（而非无参构造方法）。
- 只有当 Bean 仅存在无参构造方法，或没有其他可用的带参构造方法时，Spring 才会使用无参构造方法实例化。

也就是说，即使你实现了无参构造函数，只要还存在用于注入依赖的「带参构造方法」，Spring 依然会选择带参构造方法进行实例化，而带参构造方法的依赖约束（如 BeanA 依赖 BeanB、BeanB 依赖 BeanA）依然存在，循环依赖的死循环还是无法打破 —— 实例化 BeanA 仍需先获取 BeanB，实例化 BeanB 仍需先获取 BeanA，和是否有无参构造函数无关。

1. 构造方法注入的核心问题（实例化与依赖注入绑定）并未解决

   

   我们之前已经明确，构造方法注入循环依赖无法解决的核心是：「

   依赖注入是实例化的前提，两者无法分离，无法提前暴露未完全初始化的 Bean

   」。

仅实现无参构造函数，并没有改变「带参构造方法注入」的本质 —— 你要注入的依赖依然在带参构造器中，要完成该 Bean 的实例化（通过带参构造方法），依然需要先获取依赖的 Bean。无参构造函数只是一个「备用构造入口」，并没有消除带参构造方法的依赖约束，自然无法解决循环依赖。

举个例子：你给 BeanA 同时实现了无参构造和带参构造（依赖 BeanB），给 BeanB 也同时实现了无参构造和带参构造（依赖 BeanA），启动 Spring 容器后，依然会抛出`BeanCurrentlyInCreationException`异常，因为 Spring 会优先选择带参构造方法实例化，循环依赖的死循环依然存在。

### 三、关键：如何正确解决？（无参构造函数 + 切换注入方式）

这里要区分一个重要概念：**无参构造函数本身无法解决构造方法循环依赖，但「无参构造函数 + 切换为属性 /setter 注入」，可以解决循环依赖**—— 这也是 Spring 能正常处理循环依赖的标准方案，具体做法是：

1. 给每个 Bean 实现无参构造函数（Spring 默认要求，若未显式实现，JVM 会自动生成默认无参构造）。
2. 放弃「带参构造方法注入」，将依赖注入方式改为「属性注入（`@Autowired`字段）」或「setter 注入（`@Autowired`标注 set 方法）」，分离「实例化」和「依赖注入」。

#### 正确示例（无参构造 + 属性注入，解决循环依赖）

java



运行









```
// Bean A：无参构造 + 属性注入Bean B
@Component
public class BeanA {
    // 无参构造（显式实现，也可省略，JVM自动生成）
    public BeanA() {
    }

    // 属性注入，替代带参构造方法注入
    @Autowired
    private BeanB beanB;
}

// Bean B：无参构造 + 属性注入Bean A
@Component
public class BeanB {
    // 无参构造
    public BeanB() {
    }

    // 属性注入，替代带参构造方法注入
    @Autowired
    private BeanA beanA;
}
```

这种方案下，Spring 的处理流程如下：

1. 用无参构造函数实例化 BeanA（无需依赖任何 Bean，快速创建空对象）。
2. 将 BeanA 的早期暴露对象存入三级缓存，再去进行属性注入，发现依赖 BeanB。
3. 用无参构造函数实例化 BeanB，存入三级缓存，再去进行属性注入，发现依赖 BeanA。
4. 从三级缓存中取出 BeanA 的早期对象，完成 BeanB 的属性注入和初始化，存入一级缓存。
5. 回到 BeanA，用已初始化完成的 BeanB 完成属性注入，最终完成 BeanA 的初始化，存入一级缓存。

此时循环依赖被成功解决，核心是「无参构造实现了实例化与依赖注入的分离」，让 Spring 的三级缓存提前暴露机制能够生效，而不是仅靠无参构造函数本身。

### 总结

1. 仅实现无参构造函数，**无法解决构造方法注入的循环依赖**，因为带参构造方法的依赖约束依然存在，Spring 仍会优先选择带参构造实例化。
2. 无参构造函数的核心作用是「分离实例化与依赖注入」，但必须配合「放弃带参构造注入、切换为属性 /setter 注入」，才能真正解决循环依赖。
3. 核心逻辑不变：Spring 仅能解决「单例 + 属性 /setter 注入」的循环依赖，构造方法注入（带参）的循环依赖，仅靠无参构造无法破解。
