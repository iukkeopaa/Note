# 联合索引最左匹配原则专项判断题（含 OR/IN/ORDER BY 场景）

## 前提说明

1. 统一基于 MySQL 5.7/8.0，表 `t_goods` 已创建**联合索引 `idx_cate_brand_price (category, brand, price)`**（索引列顺序：category 左 1、brand 左 2、price 左 3）。

2. 判断题核心：判断 SQL 是否**有效利用该联合索引**（包括部分索引、覆盖索引，全表扫描 / 无法利用索引视为 “不满足”）。

3. 补充规则：

   - 最左匹配原则：必须从索引的**最左列（左 1）开始匹配**，跳过中间列后，后续列无法利用索引（范围查询后后续列也无法利用索引）。
   - 索引失效额外场景：隐式类型转换、函数操作、`OR` 两侧非索引列、无序排序等。

   

## 一、基础匹配场景（无特殊关键字）

1. `SELECT * FROM t_goods WHERE category = '电子设备';`

   ✅ 有效利用索引（匹配左 1 列 category，走索引扫描）

   解析：从最左列开始匹配，仅使用索引的 category 列，后续列无需参与，符合最左匹配。

   

2. `SELECT * FROM t_goods WHERE brand = '华为';`

   ❌ 无法利用索引（跳过左 1 列 category，直接匹配左 2 列 brand，违反最左匹配）

   解析：未从索引最左列开始，联合索引失效，触发全表扫描。

   

3. `SELECT * FROM t_goods WHERE category = '电子设备' AND brand = '华为';`

   ✅ 有效利用索引（匹配左 1 + 左 2 列，category+brand，走索引扫描）

   解析：从最左列开始，连续匹配两列，符合最左匹配，索引利用率更高。

   

4. `SELECT * FROM t_goods WHERE category = '电子设备' AND price = 2999;`

   ✅ 仅利用索引左 1 列（category），price 无法利用索引

   解析：从最左列开始匹配，但跳过了中间列 brand，后续列 price 无法借助联合索引，where 条件中 price 需回表后过滤。

   

5. `SELECT * FROM t_goods WHERE brand = '华为' AND price = 2999;`

   ❌ 无法利用索引（跳过左 1 列 category，违反最左匹配）

   解析：无最左列 category，联合索引完全失效，全表扫描。

   

6. `SELECT * FROM t_goods WHERE category = '电子设备' AND brand = '华为' AND price = 2999;`

   ✅ 有效利用完整联合索引（匹配左 1 + 左 2 + 左 3 列）

   解析：从最左列开始，连续匹配所有索引列，索引利用率最高，可直接通过索引定位数据。

   

7. `SELECT category, brand, price FROM t_goods WHERE category = '电子设备' AND brand = '华为';`

   ✅ 有效利用索引（覆盖索引，无需回表）

   解析：不仅符合最左匹配，查询的字段均在联合索引中，无需回表查询原始数据，效率更高。

   

## 二、包含 `IN` 关键字的场景

`IN` 属于「等值查询」，不破坏最左匹配原则（与 `=` 类似），只要从最左列开始匹配即可。

1. `SELECT * FROM t_goods WHERE category IN ('电子设备', '生活用品') AND brand = '华为';`

   ✅ 有效利用索引（匹配左 1 + 左 2 列，category+brand）

   解析：category 是最左列，IN 等值查询不影响索引匹配，后续 brand 可继续利用索引。

   

2. `SELECT * FROM t_goods WHERE category = '电子设备' AND brand IN ('华为', '苹果') AND price = 2999;`

   ✅ 有效利用完整联合索引（匹配左 1 + 左 2 + 左 3 列）

   解析：从最左列开始，连续等值查询（=+IN+=），符合最左匹配，可利用完整索引。

   

3. `SELECT * FROM t_goods WHERE category IN ('电子设备', '生活用品') AND price = 2999;`

   ✅ 仅利用索引左 1 列（category），price 无法利用索引

   解析：最左列 category 匹配成功，但跳过中间列 brand，price 无法借助联合索引，需回表过滤。

   

4. `SELECT * FROM t_goods WHERE brand IN ('华为', '苹果') AND price = 2999;`

   ❌ 无法利用索引（跳过左 1 列 category，违反最左匹配）

   解析：无最左列参与查询，联合索引失效，全表扫描。

   

5. `SELECT * FROM t_goods WHERE category = '电子设备' AND price IN (2999, 3999);`

   ✅ 仅利用索引左 1 列（category），price 无法利用索引

   解析：跳过中间列 brand，price 的 IN 查询无法借助联合索引，符合最左匹配的 “跳过列后后续失效” 规则。

   

## 三、包含 `OR` 关键字的场景

`OR` 对索引的要求严格：**`OR` 两侧的查询条件必须都包含索引列（且从最左列开始匹配），否则索引失效**（因为 OR 表示 “任一满足”，有一侧无索引则需全表扫描）。

1. `SELECT * FROM t_goods WHERE category = '电子设备' OR brand = '华为';`

   ❌ 无法利用索引（OR 右侧 brand 无最左列 category 支撑，整体触发全表扫描）

   解析：OR 左侧符合最左匹配，但右侧跳过了 category，单独匹配 brand 无法利用索引，MySQL 为了效率会直接全表扫描，放弃联合索引。

   

2. `SELECT * FROM t_goods WHERE category = '电子设备' OR category = '生活用品';`

   ✅ 有效利用索引（OR 两侧均为最左列 category，等值查询）

   解析：OR 两侧都是索引最左列，可转化为 `category IN (...)`，符合最左匹配，利用索引扫描。

   

3. `SELECT * FROM t_goods WHERE (category = '电子设备' AND brand = '华为') OR (category = '生活用品' AND brand = '小米');`

   ✅ 有效利用索引（OR 两侧均匹配左 1 + 左 2 列，符合最左匹配）

   解析：OR 两侧的查询条件都从最左列 category 开始，连续匹配 brand，MySQL 可利用联合索引分别扫描两侧条件，再合并结果。

   

4. `SELECT * FROM t_goods WHERE (category = '电子设备' AND price = 2999) OR brand = '华为';`

   ❌ 无法利用索引（OR 右侧 brand 无最左列支撑，全表扫描）

   解析：右侧无 category，单独匹配 brand 无法利用索引，整体全表扫描。

   

5. `SELECT * FROM t_goods WHERE category = '电子设备' OR (category = '生活用品' AND brand = '小米');`

   ✅ 有效利用索引（OR 两侧均包含最左列 category，左侧匹配左 1，右侧匹配左 1 + 左 2）

   解析：最左列 category 全程参与，右侧额外匹配 brand，符合最左匹配原则，可利用索引。

   

## 四、包含 `ORDER BY` 关键字的场景

`ORDER BY` 能否利用联合索引，取决于：**排序字段是否在索引中，且排序字段的顺序与索引列顺序一致，同时排序前的查询条件已匹配到排序字段的前序索引列（无跳过、无范围查询中断）**。

1. `SELECT * FROM t_goods WHERE category = '电子设备' ORDER BY brand;`

   ✅ 有效利用索引（排序字段 brand 是索引左 2，查询条件已匹配左 1 category，排序可利用索引）

   解析：索引列顺序是 category→brand→price，查询匹配左 1 后，排序左 2 brand，与索引顺序一致，可利用索引排序（无需额外文件排序）。

   

2. `SELECT * FROM t_goods WHERE category = '电子设备' ORDER BY price;`

   ❌ 排序无法利用索引（跳过中间列 brand，直接排序 price，索引无序）

   解析：查询条件仅匹配左 1 category，跳过左 2 brand 直接排序左 3 price，联合索引中 price 相对于 category 是无序的，需触发文件排序。

   

3. `SELECT * FROM t_goods WHERE category = '电子设备' AND brand = '华为' ORDER BY price;`

   ✅ 有效利用索引（排序字段 price 是索引左 3，查询条件已匹配左 1 + 左 2，排序与索引顺序一致）

   解析：匹配 category→brand 后，排序 price 与索引顺序一致，可利用索引排序，无文件排序。

   

4. `SELECT * FROM t_goods WHERE category > '电子设备' ORDER BY brand;`

   ❌ 排序无法利用索引（查询条件 category 是范围查询，中断索引后续匹配）

   解析：范围查询（>、<、>=、<=）会中断最左匹配的后续列，即使 brand 是索引列，排序也无法利用索引，需文件排序。

   

5. `SELECT * FROM t_goods WHERE category = '电子设备' ORDER BY brand DESC, price DESC;`

   ✅ 有效利用索引（排序方向与索引一致，且连续匹配索引列）

   解析：索引本身是升序存储，但 MySQL 支持反向扫描索引，排序方向统一（均为 DESC），且匹配左 1 后排序左 2→左 3，符合最左匹配，可利用索引。

   

6. `SELECT * FROM t_goods WHERE category = '电子设备' ORDER BY brand ASC, price DESC;`

   ❌ 排序无法利用索引（排序方向不一致，索引无法支撑）

   解析：brand 升序、price 降序，与索引的存储顺序（均升序）不一致，无法利用索引，触发文件排序。

   

7. `SELECT * FROM t_goods WHERE category = '电子设备' AND brand IN ('华为', '苹果') ORDER BY price;`

   ✅ 有效利用索引（IN 是等值查询，匹配左 1 + 左 2 后，排序左 3 price，符合索引顺序）

   解析：IN 属于等值查询，不中断索引后续匹配，排序 price 与索引顺序一致，可利用索引。

   

8. `SELECT * FROM t_goods ORDER BY category, brand;`

   ✅ 有效利用索引（排序字段为索引左 1 + 左 2，无查询条件，直接利用索引排序）

   解析：排序字段与联合索引最左列顺序一致，即使无查询条件，也可利用索引扫描排序，无需文件排序。

   

## 五、混合场景（含多关键字 + 范围查询）

1. `SELECT * FROM t_goods WHERE category = '电子设备' AND brand > '华为' ORDER BY price;`

   ❌ price 排序无法利用索引（brand 是范围查询，中断后续索引匹配）

   解析：category 等值匹配（左 1），brand 范围查询（左 2），范围查询后后续列 price 无法利用索引，排序需文件排序。

   

2. `SELECT * FROM t_goods WHERE category IN ('电子设备', '生活用品') AND brand = '华为' ORDER BY price;`

   ✅ 有效利用索引（IN 是等值查询，匹配左 1 + 左 2 后，排序左 3 price，符合最左匹配）

   解析：IN 不中断索引匹配，连续匹配 category→brand 后，排序 price 可利用索引。

   

3. `SELECT * FROM t_goods WHERE (category = '电子设备' AND brand = '华为') OR (category = '生活用品' AND brand = '小米') ORDER BY price;`

   ✅ 有效利用索引（OR 两侧均匹配左 1 + 左 2，排序左 3 price，符合索引顺序）

   解析：OR 两侧均满足最左匹配，排序字段与索引顺序一致，可利用索引排序。

   

4. `SELECT category, brand FROM t_goods WHERE category = '电子设备' AND price = 2999 ORDER BY brand;`

   ✅ 有效利用索引（覆盖索引，查询 + 排序均在索引内，无需回表）

   解析：查询字段是索引列，where 匹配左 1，排序左 2，均在联合索引内，符合最左匹配，效率最优。

   

## 总结（最左匹配原则核心提炼）

1. 核心前提：必须从索引最左列开始，跳过中间列则后续列失效。
2. 等值查询（=、IN）：不中断索引匹配，可连续利用后续索引列。
3. 范围查询（>、<、>=、<=）：中断后续索引列匹配，排序也无法利用后续列。
4. OR 关键字：两侧必须均包含最左列且符合索引匹配，否则整体全表扫描。
5. ORDER BY：排序字段需与索引列顺序一致、方向统一，且前序索引列无中断，才能利用索引。
