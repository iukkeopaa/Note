### 5. HTTP 中 GET 和 POST 的核心区别

GET 和 POST 是 HTTP 协议中最常用的两种请求方法，核心区别体现在**语义用途、数据传输、安全性、缓存性**等多个维度，具体对比如下（兼顾标准定义和实际工程实践）：

|     对比维度      |                             GET                              |                             POST                             |
| :---------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  核心语义 / 用途  |  从服务器**获取 / 查询**资源（只读操作），无副作用（幂等）   | 向服务器**提交 / 创建**资源（写操作），可能有副作用（非幂等，如提交订单、创建用户） |
|   数据传输位置    | 数据附加在**URL 后面**，以查询字符串（`key=value&key=value`）形式传递 | 数据放在 ** 请求体（Request Body）** 中传输（也可在 URL 传参，无强制限制，但不推荐） |
|    数据可见性     | URL 明文传输，浏览器地址栏、网络代理、服务器日志中均可查看到，**安全性低** | 数据在请求体中传输（默认不显示），相对隐蔽，**安全性略高**（注意：未加密的 POST 数据可通过抓包获取，真正安全需依赖 HTTPS） |
|      幂等性       | 具有幂等性（多次执行相同请求，结果一致，不会产生额外副作用，如查询用户信息） | 非幂等性（多次执行相同请求，可能产生额外副作用，如多次提交订单会创建多个订单） |
|      缓存性       | 可被浏览器、代理服务器缓存（响应头配置`Cache-Control`等即可生效） |      默认不被缓存（如需缓存，需额外配置响应头和请求头）      |
|     编码方式      | 仅支持 URL 编码（`application/x-www-form-urlencoded`），无法传输二进制数据（如文件） | 支持多种编码方式：`application/x-www-form-urlencoded`（普通表单）、`multipart/form-data`（文件上传）、`application/json`（接口请求），可传输二进制数据 |
| 浏览器回退 / 刷新 |   回退或刷新时，浏览器不会提示（因为是只读操作，无副作用）   | 回退或刷新时，浏览器会弹出提示「是否重新提交表单」（防止重复提交，产生副作用） |

补充关键要点：

- HTTP 标准中并未严格限制 GET 不能提交数据、POST 不能查询数据，两者的区别更多是**语义约定和工程实践中的规范**，但遵守约定能让接口更具可读性和可维护性。
- 不要认为 POST 比 GET 更安全，两者在未使用 HTTPS 时，数据都可被抓包获取，POST 的「安全」只是相对 URL 明文传输而言。

### 6. GET 和 POST 的长度限制是多少？

核心结论：**HTTP 标准本身没有为 GET 和 POST 定义任何长度限制**，所有的长度限制都来自「客户端（浏览器）」或「服务端（服务器软件 / 框架）」的实现限制，且 GET 和 POST 的限制来源不同。

#### （1）GET 请求的长度限制

GET 请求的数据附在 URL 上，因此其长度限制本质是**URL 的长度限制**（后续问题 8、9 会详细拆解），而非 GET 方法本身的限制：

- 客户端限制（浏览器）：主流浏览器对 URL 长度有默认限制，例如 Chrome、Firefox、Edge 的 URL 长度限制约为**2KB - 8KB**（最常见的是 Chrome 限制`2048个字符`，即 2KB），超过该长度会直接截断 URL 或拒绝发送请求。
- 服务端限制：服务器软件（Nginx、Apache）、后端框架（Spring Boot、Tomcat）会对 URL 长度做限制，例如 Tomcat 默认限制 URL 长度为`8192个字符`（8KB），Nginx 默认限制 URL 长度为`4096个字符`（4KB），超过会返回`414 Request-URI Too Long`错误。

#### （2）POST 请求的长度限制

POST 请求的数据主要在请求体（Body）中，其限制与 URL 无关，仅来自**服务端的配置限制**：

- 无客户端（浏览器）限制：浏览器对 POST 的请求体大小没有默认限制，理论上可以传输任意大小的数据（受客户端本地内存限制）。

- 服务端限制：服务器软件、后端框架会对 POST 请求体大小做限制，目的是防止超大请求占用过多服务器资源，例如：

  - Tomcat 默认限制 POST 请求体大小为`2MB`，超过返回`413 Request Entity Too Large`错误。
  - Spring Boot（基于 Tomcat）默认继承该限制，可通过`spring.servlet.multipart.max-request-size`配置修改。
  - Nginx 默认限制 POST 请求体大小为`1MB`，可通过`client_max_body_size`指令修改。

  

### 7. POST 的数据存在 Body 的最大大小是多少？

核心结论：**HTTP 标准无限制，实际最大大小由「服务端配置」决定，客户端（浏览器）无强制限制**，具体细节如下：

1. **无标准限制**：HTTP 协议本身没有对 POST 请求体（Body）的大小做任何规定，理论上可以传输任意大小的数据（如大文件、海量表单数据）。

2. 服务端限制（核心约束）

   ：这是实际项目中 POST Body 的最大大小的决定性因素，不同服务器 / 框架的默认限制和修改方式不同：

   - 「Web 服务器层面」：

     - Nginx：默认限制`1MB`，可在`nginx.conf`中通过`client_max_body_size`配置（如`client_max_body_size 100m;`表示限制为 100MB，`0`表示无限制）。
     - Apache：默认限制`8MB`，可通过`LimitRequestBody`指令配置（单位为字节，如`LimitRequestBody 104857600`表示限制为 100MB，`0`表示无限制）。

     

   - 「后端框架层面」：

     - Spring Boot：默认限制

       ```
       2MB
       ```

       （普通 POST 请求）、

       ```
       1MB
       ```

       （文件上传），可通过配置文件修改：

       yaml

       

       

       

       

       

       ```
       # 单个请求体最大大小
       spring.servlet.multipart.max-request-size: 100MB
       # 单个文件最大大小（文件上传场景）
       spring.servlet.multipart.max-file-size: 50MB
       ```

       

     - Node.js（Express）：默认无严格限制，但可通过`body-parser`中间件配置`limit`参数（如`app.use(bodyParser.json({ limit: '100mb' }))`）。

     

   

3. 额外约束：资源与性能

   ：

   

   即使服务端配置为「无限制」，也不建议传输超大的 POST Body（如 GB 级数据），因为：

   - 客户端：传输超大数据会占用大量本地内存和网络带宽，容易导致请求超时。
   - 服务端：接收、解析超大请求体会占用大量 CPU、内存资源，可能引发 OOM（内存溢出），影响服务可用性。
   - 替代方案：超大文件传输推荐使用「分片上传」「断点续传」（如阿里云 OSS、腾讯云 COS 的上传接口），而非直接通过单一 POST 请求传输。

   

### 8. URL 的最大长度是多少？

核心结论：**HTTP 标准未定义 URL 的最大长度，实际最大长度由「客户端（浏览器）」和「服务端（服务器软件 / 框架）」的实现限制共同决定**，具体数值如下：

1. **HTTP 标准：无限制**

   HTTP 协议的 RFC 规范（RFC 3986）中明确说明：「URL 的长度没有固定上限，实现者应该尽量支持任意长度的 URL」，因此 URL 的长度限制并非来自协议本身，而是来自实际的软件实现。

   

2. **客户端限制（浏览器）：主流约 2KB - 8KB**

   为了保证浏览器的稳定性和性能，主流浏览器都对 URL 长度做了默认限制，且不同浏览器的限制略有差异：

   

   - Chrome、Edge、Firefox：最常见的限制是**2048 个字符（2KB）**，部分版本支持到 8192 个字符（8KB），超过该长度会自动截断 URL，或弹出错误提示无法访问。
   - IE 浏览器：旧版本（IE6/7）限制较为严格，仅支持**2083 个字符**（其中路径部分最多 2048 个字符，查询字符串部分最多 35 个字符），现已被淘汰，无需重点关注。
   - 补充：这里的「字符」通常指 ASCII 字符，若 URL 包含中文、特殊字符等 Unicode 字符，会经过 URL 编码（如中文「测试」编码为`%E6%B5%8B%E8%AF%95`），编码后会占用更多字符长度，实际可承载的有效内容会减少。

   

3. **服务端限制：主流约 4KB - 8KB**

   服务器软件和后端框架为了防止超大 URL 引发的安全问题（如 URL 注入攻击）和性能问题，也会对 URL 长度做限制：

   

   - Tomcat：默认限制**8192 个字符（8KB）**，超过返回`414 Request-URI Too Long`错误，可通过修改`conf/server.xml`中的`maxHttpHeaderSize`参数调整。
   - Nginx：默认限制**4096 个字符（4KB）**，可通过修改`nginx.conf`中的`large_client_header_buffers`指令调整。
   - Apache：默认限制**8192 个字符（8KB）**，可通过`LimitRequestLine`指令配置（单位为字节）。

   

### 9. GET 的 URL 长度呢？

核心结论：**GET 请求的 URL 长度限制与「通用 URL 的长度限制完全一致」（无额外独立限制），即受「浏览器客户端」和「服务端」的实现限制，HTTP 标准无约束**，具体细节如下：

1. **本质关联：GET 与 URL 的绑定**

   GET 请求的核心特点是「数据附在 URL 的查询字符串中传输」，因此 GET 请求的有效数据长度直接受制于 URL 的最大长度 ——URL 的长度限制就是 GET 请求的最大数据传输长度，两者是「一体两面」的关系。

   

2. **具体限制数值（与通用 URL 一致）**

   

   - 客户端（浏览器）：主流限制约**2048 个字符（2KB）**，这是 GET 请求能传输的最大数据长度上限（超过会被浏览器截断）。
   - 服务端：主流限制约**4KB - 8KB**（Tomcat 8KB、Nginx 4KB），超过会返回`414 Request-URI Too Long`错误。

   

3. **实战注意事项**

   

   - 由于 GET 的 URL 长度有限，且明文传输，因此不适合传输「大量数据」（如超过 1KB 的表单数据）和「敏感数据」（如密码、身份证号）。
   - 若 GET 请求的查询字符串包含特殊字符（如 &、=、空格、中文），需要进行 URL 编码（`URLEncoder`），编码后会增加字符长度，可能导致原本不超限制的 URL 超出限制，实战中需注意预留字符空间。

   

### 总结

1. GET 与 POST 的核心区别是「语义用途」和「数据传输方式」，安全性和长度限制均是衍生差异。
2. 所有长度 / 大小限制（GET、POST、URL）均非 HTTP 标准定义，而是来自浏览器 / 服务器的实现约束。
3. POST Body 无浏览器限制，核心受服务端配置约束（默认 1-2MB，可修改）。
4. URL（含 GET 的 URL）主流限制：浏览器 2KB，服务端 4-8KB，超过返回 414 错误。
