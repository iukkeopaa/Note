### 一、先明确：什么是 Java 中的重入锁

重入锁（Reentrant Lock），顾名思义是**支持同一个线程重复获取同一把锁**的锁实现，它能记录当前持有锁的线程和该线程获取锁的重入次数，线程重复加锁时不会阻塞自己，释放锁时需对应重入次数完成同等次数的释放。

Java 中两种核心重入锁实现：

1. 显式重入锁：`java.util.concurrent.locks.ReentrantLock`（手动加锁 / 释放锁）
2. 隐式重入锁：`synchronized`关键字（JDK 1.6 后优化完善，自动加锁 / 释放锁）

### 二、重入锁要解决的核心问题

重入锁的核心设计目标是**解决「线程自我死锁」（也叫递归死锁 / 重复加锁死锁）问题**，同时还能满足「方法嵌套调用」「父子类方法同步」等实际开发中的合理需求。

#### 1. 先看：没有重入锁会导致什么问题（自我死锁）

如果锁不支持重入，当同一个线程已经持有某把锁，再次尝试获取该锁时，会因为「自己已经占有锁，无法再次获取」而被阻塞，最终导致线程自己卡死自己（自我死锁），无法继续执行。

举个简单的反例（假设`synchonized`不支持重入）：

java



运行









```
public class NonReentrantDemo {
    // 假设该同步方法的锁不支持重入
    public synchronized void methodA() {
        System.out.println("执行methodA");
        // 同一线程在持有methodA的锁时，调用methodB（需要同一把锁）
        methodB();
    }
    
    public synchronized void methodB() {
        System.out.println("执行methodB");
    }
    
    public static void main(String[] args) {
        NonReentrantDemo demo = new NonReentrantDemo();
        demo.methodA(); // 若锁不重入，此处会发生自我死锁
    }
}
```

上述代码中，线程调用`methodA()`时获取了对象锁，随后在`methodA()`内部调用`methodB()`，而`methodB()`同样需要获取该对象锁。如果锁不支持重入，线程会因为无法再次获取自己已持有的锁而阻塞，`methodB()`无法执行，`methodA()`也无法完成，最终陷入死锁。

#### 2. 重入锁如何解决自我死锁问题

重入锁通过「**记录锁的持有线程和重入次数**」来避免自我死锁，核心逻辑如下：

1. 当线程第一次获取锁时，锁会记录「当前持有线程」为该线程，并重入次数置为 1，同时允许线程获取锁；

2. 当该

   同一个线程再次尝试获取同一把锁

   时，锁会先判断「当前请求线程是否等于已持有线程」：

   - 若是，则直接允许获取，仅将重入次数加 1（不会阻塞线程）；
   - 若否，则按照普通锁的逻辑（阻塞或返回获取失败）处理；

   

3. 当线程释放锁时，锁会将重入次数减 1，只有当重入次数减至 0 时，才会真正释放锁（解除持有线程记录，允许其他线程获取）。

### 三、重入锁的额外价值：满足实际开发中的合理需求

除了解决自我死锁，重入锁还能支撑实际开发中常见的合理场景，让同步逻辑更灵活、更符合开发习惯：

1. 递归方法的同步需求

   ：如果一个同步方法是递归调用的，没有重入锁的话，递归过程中线程会反复尝试获取自己已持有的锁，直接导致死锁；而重入锁能正常支持递归同步，保证递归逻辑的执行。

   java

   

   运行

   

   

   

   

   ```
   public class ReentrantRecursionDemo {
       // synchronized 支持重入，可安全实现递归同步
       public synchronized int factorial(int n) {
           if (n <= 1) {
               return 1;
           }
           // 递归调用自身，重复获取同一把锁（无死锁）
           return n * factorial(n - 1);
       }
   }
   ```

   

2. 父子类方法的同步继承需求

   ：当子类重写父类的同步方法，且子类方法中调用父类的同步方法时，重入锁能保证同一线程可以重复获取锁，避免死锁且保证同步逻辑的一致性。

   java

   

   运行

   

   

   

   

   ```
   class Parent {
       public synchronized void parentMethod() {
           System.out.println("执行父类方法");
       }
   }
   
   class Child extends Parent {
       @Override
       public synchronized void parentMethod() {
           System.out.println("执行子类方法");
           // 调用父类同步方法，重复获取同一把锁（支持重入，无死锁）
           super.parentMethod();
       }
   }
   ```

   

### 总结

1. 重入锁的核心是**支持同一线程重复获取同一把锁**，解决的核心问题是「线程自我死锁」；
2. 实现原理是「记录持有线程 + 统计重入次数」，获取锁时判断线程身份，释放锁时递减次数至 0 才真正释放；
3. 额外价值是支撑「递归同步」「父子类同步继承」等实际开发场景，让同步逻辑更灵活；
4. Java 中`synchronized`（隐式）和`ReentrantLock`（显式）均支持重入，是并发编程中的基础特性。
