### 一、跳表的核心优点

跳表是一种基于有序链表的分层索引数据结构，其优点主要集中在**查询性能、插入删除效率、实现复杂度和并发友好性**这几个方面：

1. 查询 / 插入 / 删除的平均时间复杂度优异，均为 O (log n)

   

   跳表通过「分层索引」（高层索引跳过更多节点，底层索引保留完整数据）实现了类似二叉搜索树的高效查找，避免了普通有序链表 O (n) 的线性查询效率。且插入、删除操作只需找到对应节点的索引层，修改相邻节点的指针即可，无需像平衡二叉树（如红黑树）那样进行大量的旋转、变色等平衡调整操作，平均效率与红黑树持平。

2. 实现简单，易于理解和编码，维护成本低

   

   对比红黑树、AVL 树等平衡二叉树，跳表的设计思想更直观（本质是 “有序链表 + 分层索引”），没有复杂的节点颜色标记、旋转规则等约束。无论是查询、插入还是删除逻辑，代码实现都更简洁，后续调试和维护也更轻松，尤其适合需要手动实现有序数据结构的场景。

3. 支持范围查询，且效率高效

   

   跳表的底层是有序链表，在完成单点查询后，可直接沿着底层链表顺序遍历，快速获取某个区间内的所有数据，实现 O (k) 复杂度的范围查询（k 为区间内节点数量）。而红黑树等树形结构进行范围查询时，需要进行中序遍历，逻辑相对复杂，且实际执行效率并不比跳表更优。

4. 并发场景更友好，实现无锁并发更简单

   

   跳表的插入、删除操作仅涉及局部节点（对应的索引层和底层链表节点），不会像红黑树那样涉及整棵树的结构调整（影响多个节点）。基于这一特性，跳表更容易实现无锁并发操作（如使用 CAS 原子操作），在高并发场景下，能够以更低的开销保证线程安全，而红黑树的并发实现难度大，通常需要加全局锁。

5. 空间复杂度可灵活权衡，不追求绝对最优但可控

   

   跳表的空间开销主要来自分层索引，平均空间复杂度为 O (n)（最坏情况 O (n log n)，但实际场景中很难出现）。开发者可以通过调整「索引层构建概率」（通常默认 1/2，即每个节点有 50% 概率进入上一层索引），在空间开销和查询效率之间做灵活权衡，满足不同场景的需求。

### 二、跳表的核心不足（短板）

跳表并非完美的数据结构，其不足主要源于它的「分层索引特性」和「概率性平衡设计」，具体如下：

1. 空间开销高于普通有序链表，且最坏情况空间复杂度较差

   

   跳表为了提升查询效率，引入了多层索引节点，这些索引节点不存储实际业务数据（仅存储指针和索引关键字），会带来额外的空间开销。虽然平均空间复杂度是 O (n)，但对比普通有序链表的 O (n)（无额外开销），跳表的实际内存占用更高；而在最坏情况下，所有节点都被构建到所有索引层中，空间复杂度会退化到 O (n log n)，造成大量内存浪费。

2. 查询 / 插入 / 删除的最坏时间复杂度较差（O (n)），且性能不稳定

   

   跳表的平衡是「概率性平衡」，而非红黑树、AVL 树那样的「确定性平衡」。它通过随机算法决定节点的索引层数，虽然在绝大多数场景下能达到 O (log n) 的平均性能，但在极端情况下（如随机算法异常，所有节点都只构建了 1 层索引，退化为普通有序链表），其查询、插入、删除的时间复杂度会退化到 O (n)。而红黑树等平衡二叉树能保证最坏情况下的时间复杂度仍为 O (log n)，性能更稳定可靠。

3. 数据有序性是硬性前提，无有序性则无法使用

   

   跳表的分层索引和高效查询都建立在「底层链表数据严格有序」的基础上，插入数据时必须先找到其有序位置，才能完成索引层和链表的插入。如果业务场景中的数据是无序的，且无法或无需进行排序，那么跳表将无法发挥作用，而哈希表等数据结构无需依赖数据有序性，更适合此类场景。

4. 缓存友好性不如数组 / 平衡二叉树，局部性原理利用较差

   

   计算机底层的缓存优化依赖「局部性原理」（连续存储的数据更容易被缓存命中）。跳表的节点是通过指针分散存储在内存中的（索引层和底层链表的节点都不连续），访问节点时需要通过指针跳转，难以利用缓存的预加载机制；而数组（或基于数组实现的堆、有序数组）数据连续存储，红黑树等树形结构的节点也相对集中，缓存命中效率更高，在大量高频访问场景下，跳表的实际执行效率可能低于同类数据结构。

5. 对于极端高效的单点查询场景，性能略逊于红黑树

   

   虽然跳表的平均查询复杂度与红黑树持平，但跳表的查询需要逐层向下跳转（从最高层索引到低层索引，再到底层链表），涉及多次指针解引用操作；而红黑树的查询是沿着树的路径自上而下遍历，指针跳转次数更少。在对单点查询性能要求极高的极端场景下，红黑树的实际执行效率会略优于跳表。

### 总结

1. 跳表的核心优势是「高效且稳定的平均性能、实现简单、并发友好、支持高效范围查询」，适合需要有序存储、兼顾插入删除和查询效率，且不想承担复杂平衡逻辑的场景（如 Redis 的 ZSet 底层实现）；
2. 跳表的主要不足是「额外空间开销、最坏情况性能退化、依赖数据有序性、缓存友好性差」，在对内存开销敏感、要求最坏情况性能保证的场景下，红黑树等数据结构更具优势；
3. 跳表的优点和不足均源于其「分层索引」和「概率性平衡」的核心设计，选择时需结合具体业务场景权衡取舍。
