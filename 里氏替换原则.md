里式替换原则（**Liskov Substitution Principle, LSP**）是面向对象设计五大原则（SOLID）之一，由 Barbara Liskov 于 1987 年提出。其核心思想是：

> **所有引用基类（父类）的地方，必须能透明地使用其子类的对象，且不会破坏程序的正确性。**

换句话说：**子类可以扩展父类的功能，但不能改变父类原有的核心行为**。子类必须在语义上与父类保持一致，不能违背父类的约定（如方法的前置条件、后置条件、异常抛出规则等）。

### 一、里式替换原则的核心含义

里式替换原则的本质是 **「继承的正确性约束」**—— 继承关系不仅是「**is-a**」的关系，更要求「**can-do**」的行为一致性。举个反例理解：

- **错误示范**：定义父类 `Bird`（鸟），包含方法 `fly()`（飞）；子类 `Penguin`（企鹅）继承 `Bird`，但企鹅不会飞，于是重写 `fly()` 方法时直接抛出异常或空实现。此时，若程序中用 `Bird` 引用接收 `Penguin` 对象并调用 `fly()`，会导致程序崩溃或逻辑错误，**违反了里式替换原则**。
- **正确逻辑**：应该将 `Bird` 拆分为更细粒度的父类（如 `Animal` 动物、`Flyable` 可飞接口），`Penguin` 继承 `Animal` 但不实现 `Flyable`，`Sparrow`（麻雀）继承 `Animal` 并实现 `Flyable`，从设计上避免违背 LSP。

### 二、里式替换原则的核心约束（子类需遵守的规则）

要满足 LSP，子类必须遵守以下 4 个核心约束，这也是实践中判断是否符合 LSP 的标准：

1. **前置条件不能被增强**

   子类重写父类方法时，**不能增加方法的前置条件**（即方法入参的约束不能比父类更严格）。

   例：父类 `ArrayList` 的 `add(int index, E element)` 允许 `index` 取值范围是 `[0, size()]`；子类若重写该方法，不能将 `index` 范围缩小为 `[0, size()-1]`（否则父类合法的调用在子类会报错）。

   

2. **后置条件不能被减弱**

   子类重写父类方法时，**不能减弱方法的后置条件**（即方法的返回结果或副作用必须满足父类的约定）。

   例：父类 `Map` 的 `put(K key, V value)` 约定「插入键值对后，`get(key)` 必须返回对应的 `value`」；子类不能重写为「插入后 `get(key)` 返回 `null`」，这会破坏父类的后置条件。

   

3. **不变式必须保持一致**

   父类中定义的「不变式」（即无论方法如何调用，始终保持为真的逻辑），子类必须严格遵守。

   例：父类 `Stack`（栈）的不变式是「先进后出，栈顶元素始终是最后入栈的元素」；子类不能重写 `pop()` 方法为「弹出最底层元素」，这会破坏栈的不变式。

   

4. **异常抛出规则不能被破坏**

   子类重写父类方法时，**不能抛出父类方法未声明的新异常**（除非是父类异常的子类），避免调用者捕获父类异常时遗漏子类异常。

   例：父类方法声明抛出 `IOException`，子类可以抛出 `FileNotFoundException`（`IOException` 的子类），但不能抛出 `RuntimeException` 以外的其他异常（如 `SQLException`）。

   

### 三、项目实践中如何落地里式替换原则？

在 Java 项目开发（尤其是框架开发、高复用组件开发）中，遵守 LSP 能大幅提升代码的可维护性和扩展性，具体实践方法如下：

#### 1. **严格区分「继承关系」和「组合关系」，避免滥用继承**

继承的核心是 **「is-a」**，若子类和父类不是严格的「is-a」关系，应该使用 **组合 / 聚合** 替代继承，从根源上避免违背 LSP。

- **反例（违背 LSP）**：

  

  java

  

  运行

  

  

  

  

  ```
  // 父类：长方形
  class Rectangle {
      protected int width;
      protected int height;
      public void setWidth(int width) { this.width = width; }
      public void setHeight(int height) { this.height = height; }
      public int getArea() { return width * height; }
  }
  // 子类：正方形（错误地继承长方形）
  class Square extends Rectangle {
      @Override
      public void setWidth(int width) {
          // 正方形的宽高必须相等，强行修改父类逻辑
          this.width = width;
          this.height = width;
      }
      @Override
      public void setHeight(int height) {
          this.width = height;
          this.height = height;
      }
  }
  ```

  

  问题：当程序用 `Rectangle` 引用接收 `Square` 对象时，调用 `setWidth(5)` 和 `setHeight(10)`，期望面积是 `5*10=50`，但实际面积是 `10*10=100`，**破坏了父类的行为约定**。

  

- **正例（用组合替代继承）**：

  

  java

  

  运行

  

  

  

  

  ```
  // 抽象父类：四边形（只定义行为，不包含具体属性）
  abstract class Quadrilateral {
      public abstract int getArea();
  }
  // 长方形：实现四边形
  class Rectangle extends Quadrilateral {
      private int width;
      private int height;
      // 构造器初始化宽高
      public Rectangle(int width, int height) {
          this.width = width;
          this.height = height;
      }
      @Override
      public int getArea() { return width * height; }
  }
  // 正方形：实现四边形
  class Square extends Quadrilateral {
      private int side;
      public Square(int side) { this.side = side; }
      @Override
      public int getArea() { return side * side; }
  }
  ```

  

  改进：通过抽象父类定义统一行为，子类各自实现，避免了子类修改父类核心逻辑，符合 LSP。

  

#### 2. **父类优先设计为抽象类或接口，约束子类行为**

- 若父类是 **接口**：接口只定义方法签名，子类实现时只需保证方法语义与接口约定一致，天然符合 LSP（如 Java 中的 `List` 接口，`ArrayList`、`LinkedList` 等子类都能替换使用）。

- 若父类是 

  抽象类

  ：抽象类可以定义核心逻辑（模板方法），子类通过重写钩子方法扩展功能，而非修改核心逻辑，典型应用是 

  模板方法模式

  。

  java

  

  运行

  

  

  

  

  ```
  // 抽象父类：订单支付模板
  public abstract class OrderPayment {
      // 模板方法：定义支付的固定流程（核心逻辑，子类不能修改）
      public final void pay() {
          validateOrder(); // 1. 校验订单
          deductAmount();  // 2. 扣减金额
          notifyUser();    // 3. 通知用户
      }
      // 钩子方法：子类可以重写，扩展校验逻辑
      protected void validateOrder() {
          System.out.println("默认订单校验");
      }
      // 抽象方法：子类必须实现具体的扣减逻辑
      protected abstract void deductAmount();
      // 钩子方法：子类可以重写通知方式
      protected void notifyUser() {
          System.out.println("默认短信通知");
      }
  }
  // 子类：微信支付
  public class WechatPayment extends OrderPayment {
      @Override
      protected void deductAmount() {
          System.out.println("微信支付扣减金额");
      }
      // 重写钩子方法，扩展校验逻辑
      @Override
      protected void validateOrder() {
          System.out.println("微信支付：校验openid");
      }
  }
  // 子类：支付宝支付
  public class AlipayPayment extends OrderPayment {
      @Override
      protected void deductAmount() {
          System.out.println("支付宝支付扣减金额");
      }
  }
  ```

  

  优势：模板方法 

  ```
  pay()
  ```

   是 

  ```
  final
  ```

   的，子类无法修改核心流程，只能通过重写钩子方法扩展功能，保证了父类行为的一致性，完全符合 LSP。

#### 3. **子类重写父类方法时，遵循「扩展不修改」原则**

子类可以 **扩展** 父类的功能（如增加日志、参数校验），但 **不能修改** 父类原有的核心逻辑。

- **正例**：父类 `HashMap` 的 `put` 方法，子类 `LinkedHashMap` 重写 `put` 方法时，在父类逻辑基础上增加了「维护插入顺序」的功能，没有改变 `put` 方法的核心语义（插入键值对），符合 LSP。
- **反例**：若子类重写父类方法时，改变了方法的返回值语义（如父类返回 `true` 表示成功，子类返回 `true` 表示失败），则直接违背 LSP。

#### 4. **通过单元测试验证 LSP 符合性**

在项目中，针对父类编写的单元测试，应该 **能直接运行在子类上且通过测试**—— 这是验证 LSP 的最有效手段。

例：针对 `OrderPayment` 父类编写测试用例 `testPay()`，测试 `pay()` 方法是否能完成「校验→扣减→通知」流程；将该测试用例的测试对象替换为 `WechatPayment` 子类，若测试通过，说明子类符合 LSP；若测试失败，则说明子类违背了父类的行为约定。

### 四、里式替换原则的价值（项目视角）

1. **提升代码复用性**：符合 LSP 的子类可以直接替换父类，无需修改原有代码，降低了代码冗余。
2. **增强代码可维护性**：父类的逻辑变更会自动传递到所有子类，无需逐个修改子类，减少维护成本。
3. **支撑框架扩展**：Java 中的很多框架（如 Spring）都依赖 LSP 实现扩展 —— 例如 Spring 的 `BeanFactory` 接口，其多个子类（`XmlBeanFactory`、`AnnotationConfigApplicationContext`）可以无缝替换，正是因为遵守了 LSP。
4. **避免运行时错误**：违背 LSP 的代码在编译时可能不会报错，但运行时会因子类行为不一致导致难以排查的问题（如空指针、逻辑错误），遵守 LSP 能从设计层面规避这类问题。

### 总结

里式替换原则的核心是 **「子类不能破坏父类的行为约定」**。在项目实践中，关键是 **避免滥用继承**，优先使用「抽象类 / 接口 + 模板方法」的设计模式，确保子类「扩展不修改」父类逻辑，并通过单元测试验证符合性。

遵守 LSP 看似增加了设计成本，但能大幅提升代码的健壮性和扩展性 —— 这在高并发、高可用的分布式系统中尤为重要（如微服务的接口实现、组件的复用扩展）。
